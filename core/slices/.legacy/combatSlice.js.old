/**
 * Combat Slice - Manages battles, attacks, and combat state
 */

export const combatSlice = {
    name: 'combat',
    
    initialState: {
        inCombat: false,
        currentEnemy: null,
        combatLog: [],
        playerTurn: true,
        turnCount: 0,
        lastAction: null,
        damageDealt: 0,
        damageTaken: 0,
        experience: 0
    },

    actions: {
        START_COMBAT: 'START_COMBAT',
        END_COMBAT: 'END_COMBAT',
        ATTACK: 'ATTACK',
        DEFEND: 'DEFEND',
        USE_SKILL: 'USE_SKILL',
        FLEE: 'FLEE',
        ENEMY_ACTION: 'ENEMY_ACTION',
        TAKE_DAMAGE: 'TAKE_DAMAGE',
        DEAL_DAMAGE: 'DEAL_DAMAGE',
        GAIN_EXPERIENCE: 'GAIN_EXPERIENCE',
        LEVEL_UP: 'LEVEL_UP',
        ADD_COMBAT_LOG: 'ADD_COMBAT_LOG',
        CLEAR_COMBAT_LOG: 'CLEAR_COMBAT_LOG',
        END_TURN: 'END_TURN'
    },

    reducers: {
        START_COMBAT: (state, action) => {
            const { enemy } = action.payload;
            
            return {
                ...state,
                combat: {
                    ...state.combat,
                    inCombat: true,
                    currentEnemy: enemy,
                    playerTurn: true,
                    turnCount: 0,
                    combatLog: [`Combat started with ${enemy.name}!`],
                    damageDealt: 0,
                    damageTaken: 0
                },
                ui: {
                    ...state.ui,
                    currentContext: 'combat'
                }
            };
        },

        END_COMBAT: (state, action) => {
            const { victory, rewards } = action.payload || {};
            
            let newState = {
                ...state,
                combat: {
                    ...state.combat,
                    inCombat: false,
                    currentEnemy: null,
                    playerTurn: true,
                    turnCount: 0,
                    lastAction: null
                },
                ui: {
                    ...state.ui,
                    currentContext: 'floor'
                }
            };

            // Apply rewards if victorious
            if (victory && rewards) {
                if (rewards.experience) {
                    newState.player.experience += rewards.experience;
                }
                if (rewards.items) {
                    newState.player.inventory = [...newState.player.inventory, ...rewards.items];
                }
            }

            return newState;
        },

        ATTACK: (state, action) => {
            const { damage, target = 'enemy' } = action.payload;
            
            if (!state.combat.inCombat || !state.combat.playerTurn) {
                return state;
            }

            let newState = { ...state };
            let logMessage = '';

            if (target === 'enemy' && state.combat.currentEnemy) {
                // Player attacks enemy
                const newEnemyHp = Math.max(0, state.combat.currentEnemy.hp - damage);
                newState.combat.currentEnemy = {
                    ...state.combat.currentEnemy,
                    hp: newEnemyHp
                };
                newState.combat.damageDealt += damage;
                logMessage = `You attack for ${damage} damage! Enemy HP: ${newEnemyHp}`;

                // Check if enemy is defeated
                if (newEnemyHp <= 0) {
                    logMessage += ' Enemy defeated!';
                }
            }

            newState.combat.combatLog = [...state.combat.combatLog, logMessage];
            newState.combat.playerTurn = false;
            newState.combat.lastAction = 'attack';

            return newState;
        },

        DEFEND: (state, action) => {
            if (!state.combat.inCombat || !state.combat.playerTurn) {
                return state;
            }

            return {
                ...state,
                combat: {
                    ...state.combat,
                    playerTurn: false,
                    lastAction: 'defend',
                    combatLog: [...state.combat.combatLog, 'You take a defensive stance.']
                }
            };
        },

        FLEE: (state, action) => {
            if (!state.combat.inCombat) {
                return state;
            }

            const { success = true } = action.payload || {};

            if (success) {
                return {
                    ...state,
                    combat: {
                        ...state.combat,
                        inCombat: false,
                        currentEnemy: null,
                        combatLog: [...state.combat.combatLog, 'You successfully fled from combat!']
                    },
                    ui: {
                        ...state.ui,
                        currentContext: 'floor'
                    }
                };
            } else {
                return {
                    ...state,
                    combat: {
                        ...state.combat,
                        playerTurn: false,
                        combatLog: [...state.combat.combatLog, 'Failed to flee!']
                    }
                };
            }
        },

        ENEMY_ACTION: (state, action) => {
            const { actionType, damage } = action.payload;

            if (!state.combat.inCombat || state.combat.playerTurn) {
                return state;
            }

            let newState = { ...state };
            let logMessage = '';

            if (actionType === 'attack') {
                const actualDamage = state.combat.lastAction === 'defend' ? Math.floor(damage / 2) : damage;
                newState.player.hp = Math.max(0, state.player.hp - actualDamage);
                newState.combat.damageTaken += actualDamage;
                logMessage = `${state.combat.currentEnemy.name} attacks for ${actualDamage} damage! Your HP: ${newState.player.hp}`;
            }

            newState.combat.combatLog = [...state.combat.combatLog, logMessage];
            newState.combat.playerTurn = true;
            newState.combat.turnCount += 1;

            return newState;
        },

        TAKE_DAMAGE: (state, action) => {
            const { damage, source } = action.payload;
            
            const newHp = Math.max(0, state.player.hp - damage);
            
            return {
                ...state,
                player: {
                    ...state.player,
                    hp: newHp
                },
                combat: {
                    ...state.combat,
                    damageTaken: state.combat.damageTaken + damage,
                    combatLog: [...state.combat.combatLog, `You take ${damage} damage from ${source || 'unknown'}!`]
                }
            };
        },

        DEAL_DAMAGE: (state, action) => {
            const { damage, target } = action.payload;
            
            return {
                ...state,
                combat: {
                    ...state.combat,
                    damageDealt: state.combat.damageDealt + damage,
                    combatLog: [...state.combat.combatLog, `You deal ${damage} damage to ${target}!`]
                }
            };
        },

        GAIN_EXPERIENCE: (state, action) => {
            const { amount } = action.payload;
            
            return {
                ...state,
                player: {
                    ...state.player,
                    experience: state.player.experience + amount
                },
                combat: {
                    ...state.combat,
                    combatLog: [...state.combat.combatLog, `You gain ${amount} experience!`]
                }
            };
        },

        ADD_COMBAT_LOG: (state, action) => {
            const { message } = action.payload;
            
            return {
                ...state,
                combat: {
                    ...state.combat,
                    combatLog: [...state.combat.combatLog, message]
                }
            };
        },

        CLEAR_COMBAT_LOG: (state, action) => {
            return {
                ...state,
                combat: {
                    ...state.combat,
                    combatLog: []
                }
            };
        },

        END_TURN: (state, action) => {
            return {
                ...state,
                combat: {
                    ...state.combat,
                    playerTurn: !state.combat.playerTurn,
                    turnCount: state.combat.turnCount + 1
                }
            };
        }
    },

    effects: {
        START_COMBAT: (state, action, store) => {
            store.events?.emit('COMBAT_STARTED', {
                enemy: action.payload.enemy,
                player: state.player
            });
        },

        END_COMBAT: (state, action, store) => {
            const { victory, rewards } = action.payload || {};
            store.events?.emit('COMBAT_ENDED', {
                victory,
                rewards,
                player: state.player,
                combatStats: {
                    damageDealt: state.combat.damageDealt,
                    damageTaken: state.combat.damageTaken,
                    turnCount: state.combat.turnCount
                }
            });
        },

        ATTACK: (state, action, store) => {
            // Check if enemy was defeated
            if (state.combat.currentEnemy && state.combat.currentEnemy.hp <= 0) {
                setTimeout(() => {
                    store.dispatch({
                        type: 'END_COMBAT',
                        payload: {
                            victory: true,
                            rewards: {
                                experience: 10,
                                items: []
                            }
                        }
                    });
                }, 1000);
            }
        },

        ENEMY_ACTION: (state, action, store) => {
            // Check if player was defeated
            if (state.player.hp <= 0) {
                store.events?.emit('PLAYER_DEFEATED', {
                    player: state.player
                });
            }
        }
    },

    selectors: {
        isInCombat: (state) => state.combat.inCombat,
        getCurrentEnemy: (state) => state.combat.currentEnemy,
        getCombatLog: (state) => state.combat.combatLog,
        isPlayerTurn: (state) => state.combat.playerTurn,
        getTurnCount: (state) => state.combat.turnCount,
        getCombatStats: (state) => ({
            damageDealt: state.combat.damageDealt,
            damageTaken: state.combat.damageTaken,
            turnCount: state.combat.turnCount
        }),
        canAct: (state) => state.combat.inCombat && state.combat.playerTurn,
        getLastAction: (state) => state.combat.lastAction
    }
};
