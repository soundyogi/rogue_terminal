/**
 * Game Slice - Manages core game state, mode, progression, and meta information
 */

import { createSlice } from '@reduxjs/toolkit';

/**
 * Game Slice - Manages core game state, mode, progression, and meta information
 */

import { createSlice } from '@reduxjs/toolkit';

const initialState = {
    version: "1.0.0",
    timestamp: Date.now(),
    seed: 12345,
    gameMode: "gambling",
    currentGame: null,
    floor: {
        current: 1,
        layout: null,
        enemies: [],
        items: [],
        discovered: new Set(),
        exits: []
    },
    meta: {
        totalPlayTime: 0,
        gamesPlayed: 0,
        lastSaveTime: null,
        achievements: []
    }
};

const gameSlice = createSlice({
    name: 'game',
    initialState,
    reducers: {
        initializeGame: (state, action) => {
            const { mode, seed, initialState: initState } = action.payload;
            
            state.seed = seed || Math.floor(Math.random() * 1000000);
            state.gameMode = mode || 'gambling';
            state.timestamp = Date.now();
            
            if (initState) {
                Object.assign(state, initState);
            }
        },

        changeGameMode: (state, action) => {
            const { mode } = action.payload;
            state.gameMode = mode;
            state.currentGame = null; // Clear any active game session
        },

        advanceFloor: (state, action) => {
            const { floorId } = action.payload;
            state.floor.current += 1;
            state.floor.layout = null; // Will be generated based on floor
            state.floor.enemies = [];
            state.floor.items = [];
            state.floor.discovered = new Set();
            state.floor.exits = [];
        },

        startGamblingSession: (state, action) => {
            const { gameType, initialBet, opponent } = action.payload;
            
            state.currentGame = {
                type: gameType,
                bet: initialBet,
                opponent: opponent || null,
                round: 1,
                startTime: Date.now(),
                history: []
            };
            
            state.meta.gamesPlayed += 1;
        },

        endGamblingSession: (state, action) => {
            const { result, winnings } = action.payload;
            state.currentGame = null;
        },

        placeBet: (state, action) => {
            const { amount, betType } = action.payload;
            
            if (state.currentGame) {
                state.currentGame.bet = amount;
                state.currentGame.betType = betType || 'standard';
            }
        },

        makeGamblingChoice: (state, action) => {
            const { choice, data } = action.payload;
            
            if (state.currentGame) {
                state.currentGame.history.push({
                    choice: choice,
                    data: data,
                    timestamp: Date.now()
                });
                state.currentGame.round += 1;
            }
        },

        foldGame: (state, action) => {
            if (state.currentGame) {
                state.currentGame.folded = true;
                state.currentGame.endTime = Date.now();
            }
        },

        updatePlayTime: (state, action) => {
            const { deltaTime } = action.payload;
            state.meta.totalPlayTime += deltaTime;
        },

        unlockAchievement: (state, action) => {
            const { achievementId } = action.payload;
            
            if (!state.meta.achievements.includes(achievementId)) {
                state.meta.achievements.push(achievementId);
            }
        },

        saveGame: (state, action) => {
            state.meta.lastSaveTime = Date.now();
        },

        loadGame: (state, action) => {
            const { saveData } = action.payload;
            
            try {
                const loadedState = JSON.parse(saveData);
                Object.assign(state, loadedState);
                state.timestamp = Date.now();
            } catch (error) {
                console.error('Failed to load game:', error);
            }
        }
    }
});

// Export actions
export const {
    initializeGame,
    changeGameMode,
    advanceFloor,
    saveGame,
    loadGame,
    updatePlayTime,
    unlockAchievement,
    startGamblingSession,
    endGamblingSession,
    placeBet,
    makeGamblingChoice,
    foldGame
} = gameSlice.actions;

// Selectors
export const gameSelectors = {
    getGameMode: (state) => state.game.gameMode,
    getCurrentFloor: (state) => state.game.floor.current,
    getCurrentGame: (state) => state.game.currentGame,
    isGambling: (state) => state.game.currentGame !== null,
    getGameMeta: (state) => state.game.meta,
    getPlayTime: (state) => state.game.meta.totalPlayTime,
    getAchievements: (state) => state.game.meta.achievements,
    hasAchievement: (state, achievementId) => state.game.meta.achievements.includes(achievementId),
    getGameSeed: (state) => state.game.seed,
    getFloorData: (state) => state.game.floor
};

// Export the slice reducer
export default gameSlice.reducer;

// Legacy export for compatibility during migration
export const gameSlice_legacy = {
    name: 'game',
    initialState,
    actions: {
        INITIALIZE_GAME: 'game/initializeGame',
        CHANGE_GAME_MODE: 'game/changeGameMode',
        ADVANCE_FLOOR: 'game/advanceFloor',
        SAVE_GAME: 'game/saveGame',
        LOAD_GAME: 'game/loadGame',
        UPDATE_PLAY_TIME: 'game/updatePlayTime',
        UNLOCK_ACHIEVEMENT: 'game/unlockAchievement',
        START_GAMBLING_SESSION: 'game/startGamblingSession',
        END_GAMBLING_SESSION: 'game/endGamblingSession',
        PLACE_BET: 'game/placeBet',
        MAKE_GAMBLING_CHOICE: 'game/makeGamblingChoice',
        FOLD_GAME: 'game/foldGame'
    },
    reducers: gameSlice.reducer,
    selectors: gameSelectors
};

    actions: {
        INITIALIZE_GAME: 'INITIALIZE_GAME',
        CHANGE_GAME_MODE: 'CHANGE_GAME_MODE',
        ADVANCE_FLOOR: 'ADVANCE_FLOOR',
        SAVE_GAME: 'SAVE_GAME',
        LOAD_GAME: 'LOAD_GAME',
        UPDATE_PLAY_TIME: 'UPDATE_PLAY_TIME',
        UNLOCK_ACHIEVEMENT: 'UNLOCK_ACHIEVEMENT',
        START_GAMBLING_SESSION: 'START_GAMBLING_SESSION',
        END_GAMBLING_SESSION: 'END_GAMBLING_SESSION',
        PLACE_BET: 'PLACE_BET',
        MAKE_GAMBLING_CHOICE: 'MAKE_GAMBLING_CHOICE',
        FOLD_GAME: 'FOLD_GAME'
    },

    reducers: {
        INITIALIZE_GAME: (state, action) => {
            const { mode, seed, initialState } = action.payload;
            
            return {
                ...state,
                seed: seed || Math.floor(Math.random() * 1000000),
                gameMode: mode || 'gambling',
                timestamp: Date.now(),
                ...(initialState || {})
            };
        },

        CHANGE_GAME_MODE: (state, action) => {
            const { mode } = action.payload;
            
            return {
                ...state,
                gameMode: mode,
                currentGame: null // Clear any active game session
            };
        },

        ADVANCE_FLOOR: (state, action) => {
            const { floorId } = action.payload;
            const newFloor = state.floor.current + 1;
            
            return {
                ...state,
                floor: {
                    ...state.floor,
                    current: newFloor,
                    layout: null, // Will be generated based on floor
                    enemies: [],
                    items: [],
                    discovered: new Set(),
                    exits: []
                }
            };
        },

        START_GAMBLING_SESSION: (state, action) => {
            const { gameType, initialBet, opponent } = action.payload;
            
            const gameSession = {
                type: gameType,
                bet: initialBet,
                opponent: opponent || null,
                round: 1,
                startTime: Date.now(),
                history: []
            };

            return {
                ...state,
                currentGame: gameSession,
                meta: {
                    ...state.meta,
                    gamesPlayed: state.meta.gamesPlayed + 1
                }
            };
        },

        END_GAMBLING_SESSION: (state, action) => {
            const { result, winnings } = action.payload;
            
            return {
                ...state,
                currentGame: null
            };
        },

        PLACE_BET: (state, action) => {
            const { amount, betType } = action.payload;
            
            if (!state.currentGame) return state;
            
            return {
                ...state,
                currentGame: {
                    ...state.currentGame,
                    bet: amount,
                    betType: betType || 'standard'
                }
            };
        },

        MAKE_GAMBLING_CHOICE: (state, action) => {
            const { choice, data } = action.payload;
            
            if (!state.currentGame) return state;
            
            const newHistory = [...state.currentGame.history, {
                choice: choice,
                data: data,
                timestamp: Date.now()
            }];

            return {
                ...state,
                currentGame: {
                    ...state.currentGame,
                    history: newHistory,
                    round: state.currentGame.round + 1
                }
            };
        },

        FOLD_GAME: (state, action) => {
            if (!state.currentGame) return state;
            
            return {
                ...state,
                currentGame: {
                    ...state.currentGame,
                    folded: true
                }
            };
        },

        UPDATE_PLAY_TIME: (state, action) => {
            const { seconds } = action.payload;
            
            return {
                ...state,
                meta: {
                    ...state.meta,
                    totalPlayTime: state.meta.totalPlayTime + seconds
                }
            };
        },

        UNLOCK_ACHIEVEMENT: (state, action) => {
            const { achievementId } = action.payload;
            
            if (state.meta.achievements.includes(achievementId)) {
                return state; // Already unlocked
            }
            
            return {
                ...state,
                meta: {
                    ...state.meta,
                    achievements: [...state.meta.achievements, achievementId]
                }
            };
        },

        SAVE_GAME: (state, action) => {
            return {
                ...state,
                meta: {
                    ...state.meta,
                    lastSaveTime: Date.now()
                }
            };
        },

        LOAD_GAME: (state, action) => {
            const { saveData } = action.payload;
            
            try {
                const loadedState = JSON.parse(saveData);
                return {
                    ...loadedState,
                    timestamp: Date.now()
                };
            } catch (error) {
                console.error('Failed to load game:', error);
                return state;
            }
        }
    },

    effects: {
        START_GAMBLING_SESSION: (state, action, store) => {
            store.events?.emit('GAMBLING_SESSION_STARTED', {
                gameType: action.payload.gameType,
                bet: action.payload.initialBet
            });
        },

        END_GAMBLING_SESSION: (state, action, store) => {
            store.events?.emit('GAMBLING_SESSION_ENDED', {
                result: action.payload.result,
                winnings: action.payload.winnings
            });
        },

        ADVANCE_FLOOR: (state, action, store) => {
            store.events?.emit('FLOOR_ADVANCED', {
                newFloor: state.floor.current
            });
        },

        UNLOCK_ACHIEVEMENT: (state, action, store) => {
            store.events?.emit('ACHIEVEMENT_UNLOCKED', {
                achievementId: action.payload.achievementId
            });
        }
    },

    selectors: {
        getGameMode: (state) => state.gameMode,
        getCurrentFloor: (state) => state.floor.current,
        getCurrentGame: (state) => state.currentGame,
        isGambling: (state) => state.currentGame !== null,
        getGameMeta: (state) => state.meta,
        getPlayTime: (state) => state.meta.totalPlayTime,
        getAchievements: (state) => state.meta.achievements,
        hasAchievement: (state, achievementId) => state.meta.achievements.includes(achievementId),
        getGameSeed: (state) => state.seed,
        getFloorData: (state) => state.floor
    }
};
