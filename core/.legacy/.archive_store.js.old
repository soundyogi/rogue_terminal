/**
 * Redux-Style Store for Roguelike Engine
 * Single source of truth with actions, reducers, and middleware
 * Now using slice pattern for better organization
 */

import { gameRNG } from './rng.js';
import { playerSlice } from './slices/playerSlice.js';
import { uiSlice } from './slices/uiSlice.js';
import { gameSlice } from './slices/gameSlice.js';
import { inventorySlice } from './slices/inventorySlice.js';
import { combatSlice } from './slices/combatSlice.js';
import { inputSlice } from './slices/inputSlice.js';
import { createEventMiddleware, defaultEventMap } from './middleware/eventMiddleware.js';
import { thunkMiddleware } from './middleware/thunkMiddleware.js';

export class Store {
    constructor(initialState = null, actionsConfig = null) {
        this.state = initialState || this.createInitialState();
        this.actionsConfig = actionsConfig || {};
        this.reducers = new Map();
        this.middlewareStack = [];
        this.subscribers = [];
        this.history = [];
        this.maxHistorySize = 100;
        this.slices = new Map();
        
        // Register slices first
        this.registerSlice(playerSlice);
        this.registerSlice(uiSlice);
        this.registerSlice(gameSlice);
        this.registerSlice(inventorySlice);
        this.registerSlice(combatSlice);
        this.registerSlice(inputSlice);
        
        // Setup Redux-style middleware chain
        this.setupMiddleware();
    }

    /**
     * Create initial state (now incorporating slice initial states)
     */
    createInitialState() {
        return {
            version: "1.0.0",
            timestamp: Date.now(),
            seed: 12345,
            
            // Structure slice initial states properly
            player: playerSlice.initialState,
            ui: uiSlice.initialState, 
            input: inputSlice.initialState,
            floor: gameSlice.initialState.floor,
            gameMode: gameSlice.initialState.gameMode,
            currentGame: gameSlice.initialState.currentGame,
            meta: gameSlice.initialState.meta,
            combat: combatSlice.initialState,
            
            // Additional global state
            rng: gameRNG.getState(),
            flags: {},
            achievements: [],
            totalPlayTime: 0,
            gamesPlayed: 0,
            floorsCleared: 0
        };
    }

    /**
     * Setup Redux-style middleware chain
     */
    setupMiddleware() {
        // Create event middleware
        const eventMiddleware = createEventMiddleware(defaultEventMap);
        
        // Build middleware chain in Redux style
        this.middlewareStack = [
            thunkMiddleware,
            eventMiddleware,
            // Add logging middleware
            (store) => (next) => (action) => {
                console.log('Dispatching action:', action.type, action);
                return next(action);
            }
        ];
        
        // Create the dispatch chain
        this.dispatch = this.applyMiddleware(this.middlewareStack, this.baseDispatch.bind(this));
    }

    /**
     * Apply middleware chain Redux-style
     */
    applyMiddleware(middlewares, baseDispatch) {
        let dispatch = baseDispatch;
        
        const store = {
            getState: () => this.getState(),
            dispatch: (action) => dispatch(action)
        };
        
        // Create middleware chain
        const chain = middlewares.map(middleware => middleware(store));
        
        // Compose the chain from right to left
        dispatch = chain.reduceRight((next, middleware) => middleware(next), baseDispatch);
        
        return dispatch;
    }

    /**
     * Base dispatch method (called at end of middleware chain)
     */
    baseDispatch(action) {
        try {
            // Validate action
            if (!action || !action.type) {
                console.error('Action must have a type property:', action);
                return action;
            }

            // Add metadata
            const enrichedAction = {
                ...action,
                timestamp: Date.now(),
                id: `action_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
            };

            // Store current state for undo (if action is undoable)
            const actionConfig = this.actionsConfig[enrichedAction.type];
            if (actionConfig && actionConfig.undoable) {
                this.addToHistory(this.deepClone(this.state));
            }

            // Apply reducer
            const reducer = this.reducers.get(enrichedAction.type);
            if (reducer) {
                const newState = reducer(this.state, enrichedAction);
                if (newState !== this.state) {
                    this.state = newState;
                    this.state.timestamp = Date.now();
                    this.notifySubscribers(enrichedAction);
                    
                    // Run slice effects after state update
                    this.runSliceEffects(enrichedAction);
                }
            } else {
                console.warn(`No reducer for action type: ${enrichedAction.type}`);
            }

            return enrichedAction;

        } catch (error) {
            console.error('Error dispatching action:', error);
            const errorAction = { type: 'ERROR', payload: { error: error.message, action } };
            return errorAction;
        }
    }

    /**
     * Dispatch an action through the store (now Redux-style with middleware)
     * Note: This will be replaced by the middleware chain in setupMiddleware()
     */

    /**
     * Get current state (immutable copy)
     */
    getState() {
        return this.deepClone(this.state);
    }

    /**
     * Subscribe to state changes
     */
    subscribe(callback) {
        this.subscribers.push(callback);
        return () => {
            const index = this.subscribers.indexOf(callback);
            if (index !== -1) {
                this.subscribers.splice(index, 1);
            }
        };
    }

    /**
     * Register a reducer
     */
    addReducer(actionType, reducer) {
        this.reducers.set(actionType, reducer);
    }

    /**
     * Notify all subscribers of state change
     */
    notifySubscribers(action) {
        this.subscribers.forEach(callback => {
            try {
                callback(this.state, action);
            } catch (error) {
                console.error('Error in subscriber:', error);
            }
        });
    }

    /**
     * Undo last undoable action
     */
    undo() {
        if (this.history.length > 0) {
            this.state = this.history.pop();
            this.notifySubscribers({ type: 'UNDO', timestamp: Date.now() });
            return true;
        }
        return false;
    }

    /**
     * Add state to history for undo
     */
    addToHistory(state) {
        this.history.push(state);
        if (this.history.length > this.maxHistorySize) {
            this.history.shift();
        }
    }

    /**
     * Register a slice with its actions, reducers, and effects
     */
    registerSlice(slice) {
        this.slices.set(slice.name, slice);
        
        // Register all reducers from the slice
        for (const [actionType, reducer] of Object.entries(slice.reducers)) {
            this.addReducer(actionType, reducer);
        }
    }

    /**
     * Run slice effects after an action is processed
     */
    runSliceEffects(action) {
        for (const [sliceName, slice] of this.slices) {
            if (slice.effects && slice.effects[action.type]) {
                try {
                    slice.effects[action.type](this.state, action, this);
                } catch (error) {
                    console.error(`Error running effect for ${action.type} in slice ${sliceName}:`, error);
                }
            }
        }
    }

    /**
     * Get selectors from all slices
     */
    getSelectors() {
        const selectors = {};
        for (const [sliceName, slice] of this.slices) {
            if (slice.selectors) {
                selectors[sliceName] = {};
                for (const [selectorName, selector] of Object.entries(slice.selectors)) {
                    selectors[sliceName][selectorName] = (...args) => selector(this.state, ...args);
                }
            }
        }
        return selectors;
    }

    /**
     * Subscribe to events (uses event middleware)
     * Note: Events are now handled through the middleware chain
     */
    on(eventType, handler) {
        // Event handling is now done through middleware
        console.warn('Event subscription should be handled through middleware');
    }

    /**
     * Unsubscribe from events
     */
    off(eventType, handler) {
        // Event handling is now done through middleware
        console.warn('Event unsubscription should be handled through middleware');
    }

    /**
     * Emit custom events
     */
    emit(eventType, data) {
        // Event emission is now done through middleware
        console.warn('Event emission should be handled through middleware');
    }    /**
     * Deep clone utility
     */
    deepClone(obj) {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Date) return new Date(obj.getTime());
        if (obj instanceof Set) return new Set(Array.from(obj));
        if (obj instanceof Map) return new Map(Array.from(obj));
        if (Array.isArray(obj)) return obj.map(item => this.deepClone(item));
        
        const cloned = {};
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                cloned[key] = this.deepClone(obj[key]);
            }
        }
        return cloned;
    }
}

// Global store instance - will be initialized with actions config
export let store = null;

// Action creators
export const createAction = (type, payload = {}) => ({ type, payload });

// Convenience dispatch function
export const dispatch = (typeOrAction, payload) => {
    if (typeof typeOrAction === 'string') {
        return store.dispatch(createAction(typeOrAction, payload));
    } else {
        return store.dispatch(typeOrAction);
    }
};

// Initialize store with actions config
export const initializeStore = (actionsConfig) => {
    store = new Store(null, actionsConfig);
    
    // Middleware is now set up in constructor, no need to add here
    // The store already has thunk, event, and logging middleware configured
    
    return store;
};
